<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel="icon" href="/assets/images/logo.png"><title>🚀 Visualizing memory management in Golang | Technorage</title><meta name="generator" content="Jekyll v4.1.1"><meta property="og:title" content="🚀 Visualizing memory management in Golang"><meta name="author" content="deepu"><meta property="og:locale" content="en_US"><meta name="description" content="Let us take a closer look at how Golang manages memory."><meta property="og:description" content="Let us take a closer look at how Golang manages memory."><link rel="canonical" href="https://deepu.tech/memory-management-in-golang/"><meta property="og:url" content="https://deepu.tech/memory-management-in-golang/"><meta property="og:site_name" content="Technorage"><meta property="og:type" content="article"><meta property="article:published_time" content="2020-02-17T00:00:00+01:00"><meta name="twitter:card" content="summary"><meta property="twitter:title" content="🚀 Visualizing memory management in Golang"><script type="application/ld+json">{"author":{"@type":"Person","name":"deepu"},"description":"Let us take a closer look at how Golang manages memory.","@type":"BlogPosting","headline":"🚀 Visualizing memory management in Golang","dateModified":"2020-02-17T00:00:00+01:00","datePublished":"2020-02-17T00:00:00+01:00","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://deepu.tech/assets/images/logo.png"},"name":"deepu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://deepu.tech/memory-management-in-golang/"},"url":"https://deepu.tech/memory-management-in-golang/","@context":"https://schema.org"}</script><link rel="canonical" href="https://deepu.tech/memory-management-in-golang/"><meta property="og:url" content=""><meta name="monetization" content="$ilp.uphold.com/Aw7eGpxKNyK7"><meta name="twitter:site" content="@deepu105"><meta name="twitter:creator" content="@deepu105"><meta name="twitter:title" content="🚀 Visualizing memory management in Golang"><meta name="twitter:description" content="Let us take a closer look at how Golang manages memory."><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://i.imgur.com/nYAy8Ox.jpg"><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha256-L/W5Wfqfa0sdBNIKN9cG6QA5F2qx4qICmU2VgLruv9Y=" crossorigin="anonymous" as="style" onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha256-L/W5Wfqfa0sdBNIKN9cG6QA5F2qx4qICmU2VgLruv9Y=" crossorigin="anonymous"></noscript><link href="/assets/css/screen.css" rel="stylesheet"><link href="/assets/css/main.css" rel="stylesheet"></head><body class="layout-post"><noscript id="deferred-styles"><link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.9.0/css/all.css" crossorigin="anonymous"></noscript><nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down pr-md-0 pl-md-0"><div class="container d-flex align-items-center"><a class="navbar-brand" href="/"><h2 class="sitetitle">Technorage</h2><small class="sitetitlesub">Where I rage about technology and stuff! </small></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarMediumish"><ul class="navbar-nav ml-auto"><li class="nav-item"><a class="nav-link" href="/">About</a></li><li class="nav-item active"><a class="nav-link" href="/blogs/"><i class="fas fa-blog"></i> Blog</a></li><li class="nav-item"><a class="nav-link" href="/books"><i class="fas fa-book"></i> Books</a></li><li class="nav-item"><a class="nav-link" href="/appearances"><i class="fas fa-chalkboard-teacher"></i> Appearances</a></li><style>.lunrsearchresult .title{color:#d9230f}.lunrsearchresult .url{color:silver}.lunrsearchresult a{display:block;color:#777}.lunrsearchresult a:focus,.lunrsearchresult a:hover{text-decoration:none}.lunrsearchresult a:hover .title{text-decoration:underline}</style><form class="bd-search" onsubmit='return lunr_search(document.getElementById("lunrsearch").value)'><input type="text" class="form-control text-small launch-modal-search" id="lunrsearch" name="q" maxlength="255" value="" placeholder="Type and enter..."></form><div id="lunrsearchresults"><ul></ul></div></ul></div></div></nav><div class="site-content"><div class="container"><div class="main-content"><div class="container mt-5"><div class="row"><div class="col-lg-2 pl-0"><div class="sticky-top sticky-top-offset"><div class="popover-wrapper d-none d-lg-block"><a href="#"><h2 class="popover-title"><i class="fas fa-stream fa-lg"></i> TOC</h2></a><div class="popover-content"><div class="toc lead"><h3 class="font-weight-bold">Summary</h3><ul><li><a href="#go-internal-memory-structure">Go internal memory structure</a><ul><li><a href="#page-heapmheap">Page Heap(<code class="language-plaintext highlighter-rouge">mheap</code>)</a></li><li><a href="#stack">Stack</a></li></ul></li><li><a href="#go-memory-usage-stack-vs-heap">Go memory usage (Stack vs Heap)</a></li><li><a href="#go-memory-management">Go Memory management</a><ul><li><a href="#memory-allocation">Memory Allocation</a></li><li><a href="#garbage-collection">Garbage collection</a></li></ul></li><li><a href="#conclusion">Conclusion</a></li><li><a href="#references">References</a></li></ul></div></div></div><div class="share"><p>Share</p><ul><li class="ml-1 mr-1"><a target="_blank" href="https://twitter.com/intent/tweet?text=🚀 Visualizing memory management in Golang by @deepu105 &url=https://deepu.tech/memory-management-in-golang/" onclick='return window.open(this.href,"twitter-share","width=550,height=235"),!1' title="Twitter"><i class="fab fa-twitter"></i></a></li><li class="ml-1 mr-1"><a target="_blank" href="https://www.linkedin.com/shareArticle?mini=true&url=https://deepu.tech/memory-management-in-golang/" onclick='return window.open(this.href,"linkedin-share","width=550,height=435"),!1' title="Linkedin"><i class="fab fa-linkedin-in"></i></a></li><li class="ml-1 mr-1"><a target="_blank" href="https://news.ycombinator.com/submitlink?u=https://deepu.tech/memory-management-in-golang/&t=🚀 Visualizing memory management in Golang" onclick='return window.open(this.href,"hackernews-share","width=550,height=435"),!1' title="Hacker News"><i class="fab fa-hacker-news-square"></i></a></li><li class="ml-1 mr-1"><a target="_blank" href="https://www.reddit.com/submit?url=https://deepu.tech/memory-management-in-golang/&title=🚀 Visualizing memory management in Golang" onclick='return window.open(this.href,"reddit-share","width=550,height=435"),!1' title="Reddit"><i class="fab fa-reddit-square"></i></a></li><li class="ml-1 mr-1"><a target="_blank" href="https://facebook.com/sharer.php?u=https://deepu.tech/memory-management-in-golang/" onclick='return window.open(this.href,"facebook-share","width=550,height=435"),!1' title="Facebook"><i class="fab fa-facebook-f"></i></a></li></ul><div class="sep"></div><ul><li><script type="text/javascript">var HYVOR_TALK_WEBSITE=4123</script><script async type="text/javascript" src="//talk.hyvor.com/web-api/count/"></script><span data-talk-id="https://deepu.tech/memory-management-in-golang/"></span></li></ul></div><div class="ad-vertical-md"><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CE7ITK3I&placement=deeputech" id="_carbonads_js"></script></div></div></div><div class="col-lg-9 flex-first flex-lg-unordered"><div class="mainheading"><h1 class="posttitle">🚀 Visualizing memory management in Golang</h1><img data-src="https://i.imgur.com/nYAy8Ox.jpg" alt="🚀 Visualizing memory management in Golang" class="featured-image img-fluid lozad" src="/assets/images/placeholder.jpg"><div class="row post-top-meta"><div class="col-12 text-center text-md-left mb-4 mb-md-0"><img class="author-thumb lozad" src="/assets/images/placeholder.jpg" data-src="https://www.gravatar.com/avatar/7f408bc67dc9ae3b288ee92d16d3c4c2?s=250&d=mm&r=x" alt="Deepu K Sasidharan"> <a target="_blank" class="link-dark" href="https://www.deepu.tech">Deepu K Sasidharan</a><a target="_blank" href="https://twitter.com/deepu105" class="btn follow"><i class="fab fa-twitter"></i> Follow</a><span class="separator d-none d-md-inline-block">| </span><span class="author-description"><small><time class="post-date" datetime="2020-02-17">17 Feb 2020</time> </small><span class="separator d-inline-block">| </span><small>10 mins read </small><span class="separator d-inline-block d-lg-none">| </span><span class="d-inline-block d-lg-none"><div class="share" style="margin-top:0"><ul><li class="ml-1 mr-1"><a target="_blank" href="https://twitter.com/intent/tweet?text=🚀 Visualizing memory management in Golang by @deepu105 &url=https://deepu.tech/memory-management-in-golang/" onclick='return window.open(this.href,"twitter-share","width=550,height=235"),!1' title="Twitter"><i class="fab fa-twitter"></i></a></li><li class="ml-1 mr-1"><a target="_blank" href="https://www.linkedin.com/shareArticle?mini=true&url=https://deepu.tech/memory-management-in-golang/" onclick='return window.open(this.href,"linkedin-share","width=550,height=435"),!1' title="Linkedin"><i class="fab fa-linkedin-in"></i></a></li><li class="ml-1 mr-1"><a target="_blank" href="https://news.ycombinator.com/submitlink?u=https://deepu.tech/memory-management-in-golang/&t=🚀 Visualizing memory management in Golang" onclick='return window.open(this.href,"hackernews-share","width=550,height=435"),!1' title="Hacker News"><i class="fab fa-hacker-news-square"></i></a></li><li class="ml-1 mr-1"><a target="_blank" href="https://www.reddit.com/submit?url=https://deepu.tech/memory-management-in-golang/&title=🚀 Visualizing memory management in Golang" onclick='return window.open(this.href,"reddit-share","width=550,height=435"),!1' title="Reddit"><i class="fab fa-reddit-square"></i></a></li><li class="ml-1 mr-1"><a target="_blank" href="https://facebook.com/sharer.php?u=https://deepu.tech/memory-management-in-golang/" onclick='return window.open(this.href,"facebook-share","width=550,height=435"),!1' title="Facebook"><i class="fab fa-facebook-f"></i></a></li></ul></div></span></span></div></div></div><div class="panel"><p><strong>This is part of my "memory-management" series</strong></p><ol><li><a href="/memory-management-in-programming/">🚀 Demystifying memory management in modern programming languages</a></li><li><a href="/memory-management-in-jvm/">🚀 Visualizing memory management in JVM(Java, Kotlin, Scala, Groovy, Clojure)</a></li><li><a href="/memory-management-in-v8/">🚀 Visualizing memory management in V8 Engine (JavaScript, NodeJS, Deno, WebAssembly)</a></li><li><strong>🚀 Visualizing memory management in Golang</strong></li><li><a href="/memory-management-in-rust/">🚀 Visualizing memory management in Rust</a></li><li><a href="/avoiding-memory-leaks-in-nodejs/">Avoiding Memory Leaks in NodeJS: Best Practices for Performance</a></li></ol></div><div class="article-post"><p>In this multi-part series, I aim to demystify the concepts behind memory management and take a deeper look at memory management in some of the modern programming languages. I hope the series would give you some insights into what is happening under the hood of these languages in terms of memory management.</p><p>In this chapter, we will look at the memory management of the <strong><a href="https://golang.org/">Go</a></strong> programming language(Golang). Go is a statically typed &amp; compiled language like C/C++ and Rust. Hence Go does not need a VM and Go application binaries include a small runtime embedded in them to take care of language features like Garbage collection, scheduling &amp; concurrency.</p><p>If you haven’t read the <a href="https://deepu.tech/memory-management-in-programming/">first part</a> of this series, please read it first as I explained the difference between the Stack and Heap memory there which would be useful to understand this chapter.</p><blockquote><p>This post is based on Go 1.13 default official implementation and concept details might change in the future versions of Go</p></blockquote><h1 id="go-internal-memory-structure">Go internal memory structure</h1><p>First, let us see what the internal memory structure of Go is.</p><blockquote><p>Go Runtime schedules Goroutines (<code class="language-plaintext highlighter-rouge">G</code>) onto Logical Processors (<code class="language-plaintext highlighter-rouge">P</code>) for execution. Each <code class="language-plaintext highlighter-rouge">P</code> has a machine (<code class="language-plaintext highlighter-rouge">M</code>). We will use <code class="language-plaintext highlighter-rouge">P</code>, <code class="language-plaintext highlighter-rouge">M</code> &amp; <code class="language-plaintext highlighter-rouge">G</code> throughout this post. If you’re not familiar with the Go scheduler read <a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html">Go scheduler: Ms, Ps &amp; Gs</a> first.</p></blockquote><p><img src="https://i.imgur.com/wThLAbQ.png" alt="Go Scheduler"></p><p>Each Go program process is allocated some virtual memory by the Operating System(OS), this is the total memory that the process has access to. The actual memory that is used within the virtual memory is called <strong>Resident Set</strong>. This space is managed by the internal memory constructs as below:</p><p><img src="https://i.imgur.com/vFtq3uj.png" alt="Go Memory structure"></p><p>This is a simplified view based on the internal objects used by Go, In reality, Go divides and groups memory into pages as described in <a href="https://blog.learngoprogramming.com/a-visual-guide-to-golang-memory-allocator-from-ground-up-e132258453ed">this great article</a>.</p><p>This is quite different from the memory structure we saw in the previous chapters for <a href="https://deepu.tech/memory-management-in-jvm/">JVM</a> and <a href="https://deepu.tech/memory-management-in-v8/">V8</a>. As you can see there is no generational memory here. The main reason for this is the <a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html"><strong>TCMalloc</strong></a>(Thread-Caching Malloc), which is what Go’s own memory allocator was modeled upon.</p><p>Let us see what the different constructs are:</p><h2 id="page-heapmheap">Page Heap(<code class="language-plaintext highlighter-rouge">mheap</code>)</h2><p>This is where Go stores dynamic data(any data for which size cannot be calculated at compile time). This is the biggest block of memory and this is where <strong>Garbage Collection(GC)</strong> takes place.</p><p>The resident set is divided into pages of 8KB each and is managed by one global <code class="language-plaintext highlighter-rouge">mheap</code> object.</p><blockquote><p>Large objects(Object of Size &gt; 32kb) are allocated directly from <code class="language-plaintext highlighter-rouge">mheap</code>. These large requests come at an expense of central lock, so only one <code class="language-plaintext highlighter-rouge">P</code>’s request can be served at any given point in time.</p></blockquote><p><code class="language-plaintext highlighter-rouge">mheap</code> manages pages grouped into different constructs as below:</p><ul><li><p><strong>mspan</strong>: <code class="language-plaintext highlighter-rouge">mspan</code> is the most basic structure that manages the pages of memory in <code class="language-plaintext highlighter-rouge">mheap</code>. It’s a double-linked list that holds the address of the start page, span size class, and the number of pages in the span. Like TCMalloc, Go also divides Memory Pages into a block of 67 different classes by size starting at 8 bytes up to 32 kilobytes as in the below image</p><p><img src="https://i.imgur.com/IxjG2aF.png" alt=""></p><p>Each span exists twice, one for objects with pointers (<strong>scan</strong> classes) and one for objects with no pointers (<strong><code class="language-plaintext highlighter-rouge">noscan</code></strong> classes). This helps during GC as <code class="language-plaintext highlighter-rouge">noscan</code> spans need not be traversed to look for live objects.</p></li><li><p><strong>mcentral</strong>: <code class="language-plaintext highlighter-rouge">mcentral</code> groups spans of same size class together. Each <code class="language-plaintext highlighter-rouge">mcentral</code> contains two <code class="language-plaintext highlighter-rouge">mspanList</code>:</p><ul><li><strong>empty</strong>: Double linked list of spans with no free objects or spans that are cached in a <code class="language-plaintext highlighter-rouge">mcache</code>. When a span here is freed, it’s moved to the nonempty list.</li><li><strong>non-empty</strong>: Double linked list of spans with a free object. When a new span is requested from <code class="language-plaintext highlighter-rouge">mcentral</code>, it takes that from the nonempty list and moves it into the empty list.</li></ul><p>When <code class="language-plaintext highlighter-rouge">mcentral</code> doesn’t have any free span, it requests a new run of pages from <code class="language-plaintext highlighter-rouge">mheap</code>.</p></li><li><p><strong>arena</strong>: The heap memory grows and shrinks as required within the virtual memory allocated. When more memory is needed, <code class="language-plaintext highlighter-rouge">mheap</code> pulls them from the virtual memory as a chunk of 64MB(for 64-bit architectures) called <code class="language-plaintext highlighter-rouge">arena</code>. The pages are mapped to spans here.</p></li><li><p><strong>mcache</strong>: This is a very interesting construct. <code class="language-plaintext highlighter-rouge">mcache</code> is a cache of memory provided to a <code class="language-plaintext highlighter-rouge">P</code>(Logical Processor) to store small objects(Object size &lt;=32Kb). Though this resembles the thread stack, it is part of the heap and is used for dynamic data. <code class="language-plaintext highlighter-rouge">mcache</code> contains <code class="language-plaintext highlighter-rouge">scan</code> and <code class="language-plaintext highlighter-rouge">noscan</code> types of <code class="language-plaintext highlighter-rouge">mspan</code> for all class sizes. Goroutines can obtain memory from <code class="language-plaintext highlighter-rouge">mcache</code> without any locks as a <code class="language-plaintext highlighter-rouge">P</code> can have only one <code class="language-plaintext highlighter-rouge">G</code> at a time. Hence this is more efficient. <code class="language-plaintext highlighter-rouge">mcache</code> requests new spans from <code class="language-plaintext highlighter-rouge">mcentral</code> when required.</p></li></ul><h2 id="stack">Stack</h2><p>This is the stack memory area and there is one stack per Goroutine(<code class="language-plaintext highlighter-rouge">G</code>). This is where static data including function frames, static structs, primitive values, and pointers to dynamic structs are stored. This is not the same as <code class="language-plaintext highlighter-rouge">mcache</code> which is assigned to a <code class="language-plaintext highlighter-rouge">P</code></p><hr><h1 id="go-memory-usage-stack-vs-heap">Go memory usage (Stack vs Heap)</h1><p>Now that we are clear about how memory is organized let’s see how Go uses Stack and Heap when a program is executed.</p><p>Let’s use the below Go program, the code is not optimized for correctness hence ignore issues like unnecessary intermediatory variables and such, the focus is to visualize stack and heap memory usage.</p><div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="rouge-code"><pre><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">type</span> <span class="n">Employee</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">name</span>   <span class="kt">string</span>
  <span class="n">salary</span> <span class="kt">int</span>
  <span class="n">sales</span>  <span class="kt">int</span>
  <span class="n">bonus</span>  <span class="kt">int</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">BONUS_PERCENTAGE</span> <span class="o">=</span> <span class="m">10</span>

<span class="k">func</span> <span class="n">getBonusPercentage</span><span class="p">(</span><span class="n">salary</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="n">percentage</span> <span class="o">:=</span> <span class="p">(</span><span class="n">salary</span> <span class="o">*</span> <span class="n">BONUS_PERCENTAGE</span><span class="p">)</span> <span class="o">/</span> <span class="m">100</span>
  <span class="k">return</span> <span class="n">percentage</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">findEmployeeBonus</span><span class="p">(</span><span class="n">salary</span><span class="p">,</span> <span class="n">noOfSales</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="n">bonusPercentage</span> <span class="o">:=</span> <span class="n">getBonusPercentage</span><span class="p">(</span><span class="n">salary</span><span class="p">)</span>
  <span class="n">bonus</span> <span class="o">:=</span> <span class="n">bonusPercentage</span> <span class="o">*</span> <span class="n">noOfSales</span>
  <span class="k">return</span> <span class="n">bonus</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">var</span> <span class="n">john</span> <span class="o">=</span> <span class="n">Employee</span><span class="p">{</span><span class="s">"John"</span><span class="p">,</span> <span class="m">5000</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">0</span><span class="p">}</span>
  <span class="n">john</span><span class="o">.</span><span class="n">bonus</span> <span class="o">=</span> <span class="n">findEmployeeBonus</span><span class="p">(</span><span class="n">john</span><span class="o">.</span><span class="n">salary</span><span class="p">,</span> <span class="n">john</span><span class="o">.</span><span class="n">sales</span><span class="p">)</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">john</span><span class="o">.</span><span class="n">bonus</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div><p>One major difference Go has compared to many garbage collected languages is that many objects are allocated directly on the program stack. The Go compiler uses a process called <a href="https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-escape-analysis.html">escape analysis</a> to find objects whose lifetime is known at compile-time and allocates them on the stack rather than in garbage-collected heap memory. During compilation, Go does the escape analysis to determine what can go into Stack(static data) and what needs to go into Heap(dynamic data). We can see these details during compilation by running <code class="language-plaintext highlighter-rouge">go build</code> with <code class="language-plaintext highlighter-rouge">-gcflags '-m'</code> flag. For the above code, it will output something like the below:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre>❯ go build -gcflags '-m' gc.go
# command-line-arguments
temp/gc.go:14:6: can inline getBonusPercentage
temp/gc.go:19:6: can inline findEmployeeBonus
temp/gc.go:20:39: inlining call to getBonusPercentage
temp/gc.go:27:32: inlining call to findEmployeeBonus
temp/gc.go:27:32: inlining call to getBonusPercentage
temp/gc.go:28:13: inlining call to fmt.Println
temp/gc.go:28:18: john.bonus escapes to heap
temp/gc.go:28:13: io.Writer(os.Stdout) escapes to heap
temp/gc.go:28:13: main []interface {} literal does not escape
&lt;autogenerated&gt;:1: os.(*File).close .this does not escape
</pre></td></tr></tbody></table></code></pre></div></div><p>Let us visualize this. Click on the slides and move forward/backward using arrow keys to see how the above program is executed and how the stack and heap memory is used:</p><p><script async="" class="speakerdeck-embed" data-id="c237c60018de490fa71e34cef7a50f0f" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script><noscript><a href="//speakerdeck.com/player/c237c60018de490fa71e34cef7a50f0f"><img alt="Speakerdeck" class="lozad" src="{{ site.baseurl }}/assets/images/placeholder.jpg" data-src="//speakerd.s3.amazonaws.com/presentations/c237c60018de490fa71e34cef7a50f0f/slide_0.jpg"></a></noscript></p><p><em>Note: If the slides look cut off at edges, then click on the title of the slide or <a href="https://speakerdeck.com/deepu105/golang-memory-usage-stack-vs-heap">here</a> to open it directly in SpeakerDeck.</em></p><p>As you can see:</p><ul><li><strong>Main</strong> function is kept in a “main frame” on the Stack</li><li>Every function call is added to the stack memory as a frame-block</li><li>All static variables including arguments and the return value is saved within the function frame-block on the Stack</li><li>All static values regardless of type are stored directly on the Stack. This applies to global scope as well</li><li>All dynamic types are created on the Heap and is referenced from the Stack using Stack pointers. Objects of size less than 32Kb go to the <code class="language-plaintext highlighter-rouge">mcache</code> of the <code class="language-plaintext highlighter-rouge">P</code>. This applies to global scope as well</li><li>The struct with static data is kept on the stack until any dynamic value is added at that point the struct is moved to the heap</li><li>Functions called from the current function is pushed on top of the Stack</li><li>When a function returns its frame is removed from the Stack</li><li>Once the main process is complete, the objects on the Heap do not have any more pointers from Stack and becomes orphan</li></ul><p>The Stack as you can see is automatically managed and is done so by the operating system rather than Go itself. Hence we do not have to worry much about the Stack. The Heap, on the other hand, is not automatically managed by the OS and since it’s the biggest memory space and holds dynamic data, it could grow exponentially causing our program to run out of memory over time. It also becomes fragmented over time slowing down applications. This is where garbage collection comes in.</p><hr><h1 id="go-memory-management">Go Memory management</h1><p>Go’s memory management involves automatic allocation when memory is needed and garbage collection when memory is not needed anymore. It’s done by the standard library. Unlike C/C++ the developer does not have to deal with it and the underlying management done by Go is well optimized and efficient.</p><h2 id="memory-allocation">Memory Allocation</h2><p>Many programming languages that employ Garbage collection use a generational memory structure to make collection efficient along with compaction to reduce fragmentation. Go takes a different approach here, as we saw earlier, Go structures memory quite differently. Go employs a thread-local cache to speed up small object allocations and maintains <code class="language-plaintext highlighter-rouge">scan</code>/<code class="language-plaintext highlighter-rouge">noscan</code> spans to speed up GC. This structure along with the process avoids fragmentation to a great extent making compact unnecessary during GC. Let’s see how this allocation takes place.</p><p>Go decides the allocation process of an object based on its size and is divided into three categories:</p><p><strong>Tiny(size &lt; 16B)</strong>: Objects of size less than 16 bytes are allocated using the <code class="language-plaintext highlighter-rouge">mcache</code>’s tiny allocator. This is efficient and multiple tiny allocations are done on a single 16-byte block.</p><p><img src="https://i.imgur.com/Kh26oVp.gif" alt="Tiny allocation"></p><p><strong>Small(size 16B ~ 32KB)</strong>: Objects of size between 16 bytes and 32 Kilobytes are allocated on the corresponding size class(<code class="language-plaintext highlighter-rouge">mspan</code>) on <code class="language-plaintext highlighter-rouge">mcache</code> of the <code class="language-plaintext highlighter-rouge">P</code> where the <code class="language-plaintext highlighter-rouge">G</code> is running.</p><p><img src="https://i.imgur.com/PY4pZhq.gif" alt="Small allocation"></p><p>In both tiny and small allocation if the <code class="language-plaintext highlighter-rouge">mspan</code>’s list is empty the allocator will obtain a run of pages from the <code class="language-plaintext highlighter-rouge">mheap</code> to use for the <code class="language-plaintext highlighter-rouge">mspan</code>. If the <code class="language-plaintext highlighter-rouge">mheap</code> is empty or has no page runs large enough then it allocates a new group of pages (at least 1MB) from the OS.</p><p><strong>Large(size &gt; 32KB)</strong>: Objects of size greater than 32 kilobytes are allocated directly on the corresponding size class of <code class="language-plaintext highlighter-rouge">mheap</code>. If the <code class="language-plaintext highlighter-rouge">mheap</code> is empty or has no page runs large enough then it allocates a new group of pages (at least 1MB) from the OS.</p><p><img src="https://i.imgur.com/uLhLZMm.gif" alt="Large allocation"></p><p><em>Note: You can find the above GIF images as slideshow <a href="https://speakerdeck.com/deepu105/go-memory-allocation">here</a></em></p><h2 id="garbage-collection">Garbage collection</h2><p>Now that we know how Go allocates memory, let us see how it automatically collects the Heap memory which is very important for the performance of an application. When a program tries to allocate more memory on the Heap than that is freely available we encounter <strong>out of memory errors</strong>. An incorrectly managed heap could also cause a memory leak.</p><p>Go manages the heap memory by garbage collection. In simple terms, it frees the memory used by orphan objects, i.e, objects that are no longer referenced from the Stack directly or indirectly(via a reference in another object) to make space for new object creation.</p><p>As of version 1.12, the Golang uses a non-generational concurrent tri-color mark and sweep collector. The collection process roughly looks like the below, I don’t want to go into details as it changes from version to version. However, if you are interested in those, then I recommend <a href="https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html">this</a> great series.</p><p>The process starts when a certain percentage(GC Percentage) of heap allocations are done and the collector does different phases of work:</p><ul><li><strong>Mark Setup</strong> (Stop the world): When GC starts, the collector turns on <strong><a href="https://www.memorymanagement.org/glossary/w.html#term-write-barrier">write barriers</a></strong> so that data integrity can be maintained during the next concurrent phase. This step needs a very small pause as every running Goroutine is paused to enable this and then continues.</li><li><strong>Marking</strong> (Concurrent): Once write barriers are turned on the actual marking process is started in parallel to the application using 25% of the available CPU capacity. The corresponding <code class="language-plaintext highlighter-rouge">P</code>s are reserved until marking is complete. This is done using dedicated Goroutines. Here the GC marks values in the heap that is alive(referenced from the Stack of any active Goroutines). When collection takes longer the process may employ active Goroutine from application to assist in the marking process. this is called <strong>Mark Assist</strong>.</li><li><strong>Mark Termination</strong> (Stop the world): Once marking is done every active Goroutine is paused and write barriers are turned off and clean up tasks are started. The GC also calculates the next GC goal here. Once this is done the reserved <code class="language-plaintext highlighter-rouge">P</code>s are released back to the application.</li><li><strong>Sweeping</strong> (Concurrent): Once the collection is done and allocations are attempted, the sweeping process starts to reclaim memory from the heap that is not marked alive. The amount of memory swept is synchronous to the amount being allocated.</li></ul><p>Let us see these in action for a single Goroutine. The number of objects is kept small for brevity. Click on the slides and move forward/backward using arrow keys to see the process:</p><p><script async="" class="speakerdeck-embed" data-id="f162d0725e1940a69bdbb8c0cd9e302a" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script><noscript><a href="//speakerdeck.com/player/f162d0725e1940a69bdbb8c0cd9e302a"><img alt="Speakerdeck" class="lozad" src="{{ site.baseurl }}/assets/images/placeholder.jpg" data-src="//speakerd.s3.amazonaws.com/presentations/f162d0725e1940a69bdbb8c0cd9e302a/slide_0.jpg"></a></noscript></p><p><em>Note: If the slides look cut off at edges, then click on the title of the slide or <a href="https://speakerdeck.com/deepu105/go-gc-visualized">here</a> to open it directly in SpeakerDeck.</em></p><ol><li>We are looking at a single Goroutine, the actual process does this for all active Goroutines. The write barriers are turned on first.</li><li>The marking process picks a GC root and colors it black and traverses pointers from it in a depth-first tree-like manner, it marks each object encountered grey</li><li>When it reaches an object in a <code class="language-plaintext highlighter-rouge">noscan</code> span or when an object has no more pointers it finishes for the root and picks up the next GC root object</li><li>Once all GC roots are scanned, it picks up a grey object and continues to traverse its pointers in a similar fashion</li><li>If there are any pointer changes to an object when write barriers are on, the object gets colored grey so that GC re-scans it</li><li>When there are no more grey objects left, the marking process is complete and the write barrier is turned off</li><li>Sweeping will take place when allocations start</li></ol><p>This has some stop-the-world process but it’s generally very fast that it is negligible most of the time. The coloring of objects takes place in the <code class="language-plaintext highlighter-rouge">gcmarkBits</code> attribute on the span.</p><hr><h1 id="conclusion">Conclusion</h1><p>This post should give you an overview of the Go memory structure and memory management. This is not exhaustive, there are a lot more advanced concepts and the implementation details keep changing from version to version. But for most Go developers this level of information would be sufficient and I hope it helps you write better code, considering these in mind, for more performant applications, and keeping these in mind would help you to avoid the next memory leak issue you might encounter otherwise.</p><p>I hope you had fun learning this, stay tuned for the next post in the series.</p><hr><h1 id="references">References</h1><ul><li><a href="https://blog.learngoprogramming.com/a-visual-guide-to-golang-memory-allocator-from-ground-up-e132258453ed">blog.learngoprogramming.com</a></li><li><a href="https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html">www.ardanlabs.com</a></li><li><a href="https://povilasv.me/go-memory-management/">povilasv.me</a></li><li><a href="https://medium.com/a-journey-with-go/go-memory-management-and-allocation-a7396d430f44">medium.com/a-journey-with-go</a></li><li><a href="https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-mark-the-memory-72cfc12c6976">medium.com/a-journey-with-go</a></li><li><a href="https://hub.packtpub.com/implementing-memory-management-with-golang-garbage-collector/">hub.packtpub.com</a></li><li><a href="https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice/">making.pusher.com</a></li><li><a href="https://segment.com/blog/allocation-efficiency-in-high-performance-go-services/">segment.com/blog</a></li><li><a href="https://go101.org/article/memory-block.html">go101.org</a></li></ul><hr><p>If you like this article, please leave a like or a comment.</p><p>You can follow me on <a href="https://twitter.com/deepu105">Twitter</a> and <a href="https://www.linkedin.com/in/deepu05/">LinkedIn</a>.</p><p>Cover image inspired by <a href="https://medium.com/a-journey-with-go/go-discovery-of-the-trace-package-e5a821743c3c">a-journey-with-go</a></p></div><hr><p>Post <strong>4</strong> of <strong>6</strong> in series <strong>"memory-management"</strong>.</p><p></p><div class="row PageNavigation d-flex justify-content-between font-weight-bold"><a class="prev d-block col-md-6" rel="prev" href="/memory-management-in-v8/">&laquo; Prev post in series</a> <a class="prev d-block col-md-6 text-right" rel="next" href="/memory-management-in-rust/">Next post in series &raquo;</a><div class="clearfix"></div></div><div class="after-post-cats"><ul class="tags mb-4"></ul></div><div class="after-post-tags"><ul class="tags"><li><a class="smoothscroll" href="/tags#computerscience">#computerscience</a></li><li><a class="smoothscroll" href="/tags#garbagecollection">#garbagecollection</a></li><li><a class="smoothscroll" href="/tags#go">#go</a></li><li><a class="smoothscroll" href="/tags#programming">#programming</a></li></ul></div><div class="row PageNavigation d-flex justify-content-between font-weight-bold"><a class="prev d-block col-md-6" href="/polyglot-showdown-with-graalvm/">&laquo; Polyglot inception with GraalVM. Why? Because it's fun 🏄</a> <a class="next d-block col-md-6 text-lg-right" href="/deno-runtime-for-typescript/">Forget NodeJS! Build native TypeScript applications with Deno 🦖 &raquo;</a><div class="clearfix"></div></div><hr></div></div></div><div class="container"><div id="comments" class="row justify-content-center mb-5"><div class="col-md-8"><section class="hyvor"><div id="hyvor-talk-view"></div><script type="text/javascript">var HYVOR_TALK_WEBSITE=4123,HYVOR_TALK_CONFIG={url:"https://deepu.tech/memory-management-in-golang/",id:"https://deepu.tech/memory-management-in-golang/"}</script><script async type="text/javascript" src="//talk.hyvor.com/web-api/embed"></script></section></div></div></div></div><div class="alertbar"><div class="container text-center"><span>Never miss a <b>story</b> from us, subscribe to our newsletter</span><form action="https://tech.us7.list-manage.com/subscribe/post?u=00729f6c6d6bb180801b9484e&amp;id=f521dede4b" method="post" name="mc-embedded-subscribe-form" id="mc-embedded-subscribe-form" class="wj-contact-form validate" target="_blank" novalidate><div class="mc-field-group"><input type="email" placeholder="Email address" name="EMAIL" class="required email" id="mce-EMAIL" autocomplete="on" required> <input type="submit" value="Subscribe" name="subscribe" class="heart"></div></form></div></div></div><div class="jumbotron fortags lozad" data-background-image="/assets/images/jumbotron.jpg"><div class="d-md-flex h-100"><div class="col-md-4 transpdark align-self-center text-center h-100"><div class="d-md-flex align-items-center justify-content-center h-100"><h2 class="d-md-block align-self-center py-1 font-weight-light">Explore <span class="d-none d-md-inline">→</span></h2></div></div><div class="col-md-8 pt-1 ph-2 align-self-center text-center h-100"><a class="mt-1 mb-1" href="/tags#languages">languages (15)</a> <a class="mt-1 mb-1" href="/tags#programming">programming (15)</a> <a class="mt-1 mb-1" href="/tags#javascript">javascript (13)</a> <a class="mt-1 mb-1" href="/tags#java">java (11)</a> <a class="mt-1 mb-1" href="/tags#beginners">beginners (8)</a> <a class="mt-1 mb-1" href="/tags#rust">rust (8)</a> <a class="mt-1 mb-1" href="/tags#concurrency">concurrency (7)</a> <a class="mt-1 mb-1" href="/tags#go">go (7)</a> <a class="mt-1 mb-1" href="/tags#linux">linux (5)</a> <a class="mt-1 mb-1" href="/tags#microservices">microservices (5)</a> <a class="mt-1 mb-1" href="/tags#typescript">typescript (5)</a> <a class="mt-1 mb-1" href="/tags#computerscience">computerscience (4)</a> <a class="mt-1 mb-1" href="/tags#development">development (4)</a> <a class="mt-1 mb-1" href="/tags#fedora">fedora (4)</a> <a class="mt-1 mb-1" href="/tags#functional">functional (4)</a> <a class="mt-1 mb-1" href="/tags#thepragmaticprogrammer">thepragmaticprogrammer (4)</a> <a class="mt-1 mb-1" href="/tags#async">async (3)</a> <a class="mt-1 mb-1" href="/tags#jhipster">jhipster (3)</a> <a class="mt-1 mb-1" href="/tags#kubernetes">kubernetes (3)</a> <a class="mt-1 mb-1" href="/tags#azure">azure (2)</a> <a class="mt-1 mb-1" href="/tags#career">career (2)</a> <a class="mt-1 mb-1" href="/tags#codequality">codequality (2)</a> <a class="mt-1 mb-1" href="/tags#deno">deno (2)</a> <a class="mt-1 mb-1" href="/tags#discuss">discuss (2)</a> <a class="mt-1 mb-1" href="/tags#docker">docker (2)</a> <a class="mt-1 mb-1" href="/tags#garbagecollection">garbagecollection (2)</a> <a class="mt-1 mb-1" href="/tags#gnome">gnome (2)</a> <a class="mt-1 mb-1" href="/tags#golang">golang (2)</a> <a class="mt-1 mb-1" href="/tags#kde">kde (2)</a> <a class="mt-1 mb-1" href="/tags#node">node (2)</a> <a class="mt-1 mb-1" href="/tags#nodejs">nodejs (2)</a> <a class="mt-1 mb-1" href="/tags#openjdk">openjdk (2)</a> <a class="mt-1 mb-1" href="/tags#react">react (2)</a> <a class="mt-1 mb-1" href="/tags#showdev">showdev (2)</a> <a class="mt-1 mb-1" href="/tags#webdev">webdev (2)</a> <a class="mt-1 mb-1" href="/tags#architecture">architecture (1)</a> <a class="mt-1 mb-1" href="/tags#bash">bash (1)</a> <a class="mt-1 mb-1" href="/tags#blogging">blogging (1)</a> <a class="mt-1 mb-1" href="/tags#books">books (1)</a> <a class="mt-1 mb-1" href="/tags#clojure">clojure (1)</a> <a class="mt-1 mb-1" href="/tags#codenewbie">codenewbie (1)</a> <a class="mt-1 mb-1" href="/tags#desktop">desktop (1)</a> <a class="mt-1 mb-1" href="/tags#developerexperience">developerexperience (1)</a> <a class="mt-1 mb-1" href="/tags#devops">devops (1)</a> <a class="mt-1 mb-1" href="/tags#devrel">devrel (1)</a> <a class="mt-1 mb-1" href="/tags#distributedsystems">distributedsystems (1)</a> <a class="mt-1 mb-1" href="/tags#engineering">engineering (1)</a> <a class="mt-1 mb-1" href="/tags#gaming">gaming (1)</a> <a class="mt-1 mb-1" href="/tags#ide">ide (1)</a> <a class="mt-1 mb-1" href="/tags#interview">interview (1)</a> <a class="mt-1 mb-1" href="/tags#istio">istio (1)</a> <a class="mt-1 mb-1" href="/tags#jdk">jdk (1)</a> <a class="mt-1 mb-1" href="/tags#Jekyll">Jekyll (1)</a> <a class="mt-1 mb-1" href="/tags#js">js (1)</a> <a class="mt-1 mb-1" href="/tags#jvm">jvm (1)</a> <a class="mt-1 mb-1" href="/tags#kotlin">kotlin (1)</a> <a class="mt-1 mb-1" href="/tags#loom">loom (1)</a> <a class="mt-1 mb-1" href="/tags#medium">medium (1)</a> <a class="mt-1 mb-1" href="/tags#memory-management">memory-management (1)</a> <a class="mt-1 mb-1" href="/tags#motivation">motivation (1)</a> <a class="mt-1 mb-1" href="/tags#multithreading">multithreading (1)</a> <a class="mt-1 mb-1" href="/tags#ohmyzsh">ohmyzsh (1)</a> <a class="mt-1 mb-1" href="/tags#opensource">opensource (1)</a> <a class="mt-1 mb-1" href="/tags#patternmatching">patternmatching (1)</a> <a class="mt-1 mb-1" href="/tags#polyglot">polyglot (1)</a> <a class="mt-1 mb-1" href="/tags#pragmatic">pragmatic (1)</a> <a class="mt-1 mb-1" href="/tags#python">python (1)</a> <a class="mt-1 mb-1" href="/tags#ruby">ruby (1)</a> <a class="mt-1 mb-1" href="/tags#scala">scala (1)</a> <a class="mt-1 mb-1" href="/tags#svelte">svelte (1)</a> <a class="mt-1 mb-1" href="/tags#tech">tech (1)</a> <a class="mt-1 mb-1" href="/tags#terminal">terminal (1)</a> <a class="mt-1 mb-1" href="/tags#terraform">terraform (1)</a> <a class="mt-1 mb-1" href="/tags#ubuntu">ubuntu (1)</a> <a class="mt-1 mb-1" href="/tags#v8">v8 (1)</a> <a class="mt-1 mb-1" href="/tags#vr">vr (1)</a> <a class="mt-1 mb-1" href="/tags#vscode">vscode (1)</a> <a class="mt-1 mb-1" href="/tags#web">web (1)</a> <a class="mt-1 mb-1" href="/tags#WebAssembly">WebAssembly (1)</a> <a class="mt-1 mb-1" href="/tags#webassembly">webassembly (1)</a> <a class="mt-1 mb-1" href="/tags#windows">windows (1)</a> <a class="mt-1 mb-1" href="/tags#womenintech">womenintech (1)</a> <a class="mt-1 mb-1" href="/tags#writing">writing (1)</a> <a class="mt-1 mb-1" href="/tags#zsh">zsh (1)</a></div></div></div><footer class="footer"><div class="container"><div class="row"><div class="col-md-6 col-sm-6 text-center text-lg-left">Copyright © 2022 Deepu K Sasidharan<br><a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img class="lozad" alt="Creative Commons License" style="border-width:0" src="/assets/images/placeholder.jpg" data-src="https://i.creativecommons.org/l/by/4.0/88x31.png"> </a>Content licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</div><div class="col-md-6 col-sm-6 text-center text-lg-right"><a target="_blank" href="https://www.wowthemes.net/mediumish-free-jekyll-template/">Mediumish Jekyll Theme</a> by WowThemes.net | Domain by <a href="https://js.org" target="_blank" title="JS.ORG | JavaScript Community"><img src="/assets/images/placeholder.jpg" data-src="https://logo.js.org/dark_tiny.png" style="width:50px" alt="JS.ORG Logo" class="lozad"> </a>| Hosted with <i class="far fa-heart"></i> by <a href="https://pages.github.com/" target="_blank">Github</a></div></div></div></footer></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.slim.min.js" integrity="sha256-pasqAKBDmFT4eHoN2ndd6lN370kFiGUFyTiUHWhU7k8=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.8/lunr.min.js" integrity="sha256-34Si1Y6llMBKM3G0jQILVeoQKEwuxjbk4zGWXXMT4ps=" crossorigin="anonymous"></script><script async src="/assets/js/lunrsearchengine.js"></script><script async src="/assets/js/mediumish.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.14.0/lozad.min.js" integrity="sha256-hstwhDmGVwZjIwt6SlTG6sQBREWrWTBjVTik/JLlb1Y=" crossorigin="anonymous"></script><script>// lazy loads images
        const lazyloadObserver = lozad()
        lazyloadObserver.observe();</script><script async src="/assets/js/ie10-viewport-bug-workaround.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-74370272-6"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-74370272-6")</script></body></html>