<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel="icon" href="/assets/images/logo.png"><title>Easy functional programming techniques in Rust for everyone | Technorage</title><meta name="generator" content="Jekyll v4.1.1"><meta property="og:title" content="Easy functional programming techniques in Rust for everyone"><meta name="author" content="deepu"><meta property="og:locale" content="en_US"><meta name="description" content="Functional programming concepts in Rust for beginners."><meta property="og:description" content="Functional programming concepts in Rust for beginners."><link rel="canonical" href="https://deepu.tech/functional-programming-in-rust/"><meta property="og:url" content="https://deepu.tech/functional-programming-in-rust/"><meta property="og:site_name" content="Technorage"><meta property="og:type" content="article"><meta property="article:published_time" content="2019-11-14T00:00:00+05:30"><meta name="twitter:card" content="summary"><meta property="twitter:title" content="Easy functional programming techniques in Rust for everyone"><script type="application/ld+json">{"datePublished":"2019-11-14T00:00:00+05:30","description":"Functional programming concepts in Rust for beginners.","mainEntityOfPage":{"@type":"WebPage","@id":"https://deepu.tech/functional-programming-in-rust/"},"author":{"@type":"Person","name":"deepu"},"@type":"BlogPosting","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://deepu.tech/assets/images/logo.png"},"name":"deepu"},"url":"https://deepu.tech/functional-programming-in-rust/","headline":"Easy functional programming techniques in Rust for everyone","dateModified":"2019-11-14T00:00:00+05:30","@context":"https://schema.org"}</script><link rel="canonical" href="https://deepu.tech/functional-programming-in-rust/"><meta property="og:url" content=""><meta name="monetization" content="$ilp.uphold.com/Aw7eGpxKNyK7"><meta name="twitter:site" content="@deepu105"><meta name="twitter:creator" content="@deepu105"><meta name="twitter:title" content="Easy functional programming techniques in Rust for everyone"><meta name="twitter:description" content="Functional programming concepts in Rust for beginners."><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://thepracticaldev.s3.amazonaws.com/i/8jy8jkp8bwlufob52bgu.png"><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha256-L/W5Wfqfa0sdBNIKN9cG6QA5F2qx4qICmU2VgLruv9Y=" crossorigin="anonymous" as="style" onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha256-L/W5Wfqfa0sdBNIKN9cG6QA5F2qx4qICmU2VgLruv9Y=" crossorigin="anonymous"></noscript><link href="/assets/css/screen.css" rel="stylesheet"><link href="/assets/css/main.css" rel="stylesheet"></head><body class="layout-post"><noscript id="deferred-styles"><link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.9.0/css/all.css" crossorigin="anonymous"></noscript><nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down pr-md-0 pl-md-0"><div class="container d-flex align-items-center"><a class="navbar-brand" href="/"><h2 class="sitetitle">Technorage</h2><small class="sitetitlesub">Where I rage about technology and stuff! </small></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarMediumish"><ul class="navbar-nav ml-auto"><li class="nav-item"><a class="nav-link" href="/">About</a></li><li class="nav-item active"><a class="nav-link" href="/blogs/"><i class="fas fa-blog"></i> Blog</a></li><li class="nav-item"><a class="nav-link" href="/books"><i class="fas fa-book"></i> Books</a></li><li class="nav-item"><a class="nav-link" href="/appearances"><i class="fas fa-chalkboard-teacher"></i> Appearances</a></li><style>.lunrsearchresult .title{color:#d9230f}.lunrsearchresult .url{color:silver}.lunrsearchresult a{display:block;color:#777}.lunrsearchresult a:focus,.lunrsearchresult a:hover{text-decoration:none}.lunrsearchresult a:hover .title{text-decoration:underline}</style><form class="bd-search" onsubmit='return lunr_search(document.getElementById("lunrsearch").value)'><input type="text" class="form-control text-small launch-modal-search" id="lunrsearch" name="q" maxlength="255" value="" placeholder="Type and enter..."></form><div id="lunrsearchresults"><ul></ul></div></ul></div></div></nav><div class="site-content"><div class="container"><div class="main-content"><div class="container mt-5"><div class="row"><div class="col-lg-2 pl-0"><div class="sticky-top sticky-top-offset"><div class="popover-wrapper d-none d-lg-block"><a href="#"><h2 class="popover-title"><i class="fas fa-stream fa-lg"></i> TOC</h2></a><div class="popover-content"><div class="toc lead"><h3 class="font-weight-bold">Summary</h3><ul><li><a href="#what-is-functional-programming">What is functional programming?</a></li><li><a href="#functional-programming-in-rust">Functional programming in Rust</a><ul><li><a href="#first-class-and-higher-order-functions">First-class and higher-order functions</a></li><li><a href="#pure-functions">Pure functions</a></li><li><a href="#recursion">Recursion</a></li><li><a href="#lazy-evaluation">Lazy evaluation</a></li><li><a href="#type-system">Type system</a></li><li><a href="#referential-transparency">Referential transparency</a></li><li><a href="#data-structures"><a href="https://en.wikipedia.org/wiki/Purely_functional_data_structure">Data structures</a></a></li></ul></li><li><a href="#conclusion">Conclusion</a></li></ul></div></div></div><div class="share"><p>Share</p><ul><li class="ml-1 mr-1"><a target="_blank" href="https://twitter.com/intent/tweet?text=Easy functional programming techniques in Rust for everyone by @deepu105 &url=https://deepu.tech/functional-programming-in-rust/" onclick='return window.open(this.href,"twitter-share","width=550,height=235"),!1' title="Twitter"><i class="fab fa-twitter"></i></a></li><li class="ml-1 mr-1"><a target="_blank" href="https://www.linkedin.com/shareArticle?mini=true&url=https://deepu.tech/functional-programming-in-rust/" onclick='return window.open(this.href,"linkedin-share","width=550,height=435"),!1' title="Linkedin"><i class="fab fa-linkedin-in"></i></a></li><li class="ml-1 mr-1"><a target="_blank" href="https://news.ycombinator.com/submitlink?u=https://deepu.tech/functional-programming-in-rust/&t=Easy functional programming techniques in Rust for everyone" onclick='return window.open(this.href,"hackernews-share","width=550,height=435"),!1' title="Hacker News"><i class="fab fa-hacker-news-square"></i></a></li><li class="ml-1 mr-1"><a target="_blank" href="https://www.reddit.com/submit?url=https://deepu.tech/functional-programming-in-rust/&title=Easy functional programming techniques in Rust for everyone" onclick='return window.open(this.href,"reddit-share","width=550,height=435"),!1' title="Reddit"><i class="fab fa-reddit-square"></i></a></li><li class="ml-1 mr-1"><a target="_blank" href="https://facebook.com/sharer.php?u=https://deepu.tech/functional-programming-in-rust/" onclick='return window.open(this.href,"facebook-share","width=550,height=435"),!1' title="Facebook"><i class="fab fa-facebook-f"></i></a></li></ul><div class="sep"></div><ul><li><script type="text/javascript">var HYVOR_TALK_WEBSITE=4123</script><script async type="text/javascript" src="//talk.hyvor.com/web-api/count/"></script><span data-talk-id="https://deepu.tech/functional-programming-in-rust/"></span></li></ul></div><div class="ad-vertical-md"><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CE7ITK3I&placement=deeputech" id="_carbonads_js"></script></div></div></div><div class="col-lg-9 flex-first flex-lg-unordered"><div class="mainheading"><h1 class="posttitle">Easy functional programming techniques in Rust for everyone</h1><img data-src="https://thepracticaldev.s3.amazonaws.com/i/8jy8jkp8bwlufob52bgu.png" alt="Easy functional programming techniques in Rust for everyone" class="featured-image img-fluid lozad" src="/assets/images/placeholder.jpg"><div class="row post-top-meta"><div class="col-12 text-center text-md-left mb-4 mb-md-0"><img class="author-thumb lozad" src="/assets/images/placeholder.jpg" data-src="https://www.gravatar.com/avatar/7f408bc67dc9ae3b288ee92d16d3c4c2?s=250&d=mm&r=x" alt="Deepu K Sasidharan"> <a target="_blank" class="link-dark" href="https://www.deepu.tech">Deepu K Sasidharan</a><a target="_blank" href="https://twitter.com/deepu105" class="btn follow"><i class="fab fa-twitter"></i> Follow</a><span class="separator d-none d-md-inline-block">| </span><span class="author-description"><small><time class="post-date" datetime="2019-11-14">14 Nov 2019</time> </small><span class="separator d-inline-block">| </span><small>12 mins read </small><span class="separator d-inline-block d-lg-none">| </span><span class="d-inline-block d-lg-none"><div class="share" style="margin-top:0"><ul><li class="ml-1 mr-1"><a target="_blank" href="https://twitter.com/intent/tweet?text=Easy functional programming techniques in Rust for everyone by @deepu105 &url=https://deepu.tech/functional-programming-in-rust/" onclick='return window.open(this.href,"twitter-share","width=550,height=235"),!1' title="Twitter"><i class="fab fa-twitter"></i></a></li><li class="ml-1 mr-1"><a target="_blank" href="https://www.linkedin.com/shareArticle?mini=true&url=https://deepu.tech/functional-programming-in-rust/" onclick='return window.open(this.href,"linkedin-share","width=550,height=435"),!1' title="Linkedin"><i class="fab fa-linkedin-in"></i></a></li><li class="ml-1 mr-1"><a target="_blank" href="https://news.ycombinator.com/submitlink?u=https://deepu.tech/functional-programming-in-rust/&t=Easy functional programming techniques in Rust for everyone" onclick='return window.open(this.href,"hackernews-share","width=550,height=435"),!1' title="Hacker News"><i class="fab fa-hacker-news-square"></i></a></li><li class="ml-1 mr-1"><a target="_blank" href="https://www.reddit.com/submit?url=https://deepu.tech/functional-programming-in-rust/&title=Easy functional programming techniques in Rust for everyone" onclick='return window.open(this.href,"reddit-share","width=550,height=435"),!1' title="Reddit"><i class="fab fa-reddit-square"></i></a></li><li class="ml-1 mr-1"><a target="_blank" href="https://facebook.com/sharer.php?u=https://deepu.tech/functional-programming-in-rust/" onclick='return window.open(this.href,"facebook-share","width=550,height=435"),!1' title="Facebook"><i class="fab fa-facebook-f"></i></a></li></ul></div></span></span></div></div></div><div class="panel"><p><strong>This is part of my "functional-programming" series</strong></p><ol><li><a href="/functional-programming-in-java-for-beginners/">7 Functional programming techniques in Java - A primer</a></li><li><a href="/functional-programming-in-go/">7 Easy functional programming techniques in Go</a></li><li><a href="/functional-programming-in-typescript/">Easy functional programming techniques in TypeScript for everyone</a></li><li><strong>Easy functional programming techniques in Rust for everyone</strong></li></ol></div><div class="article-post"><p>There is a lot of hype around functional programming(FP) and a lot of cool kids are doing it but it is not a silver bullet. Like other programming paradigms/styles, functional programming also has its pros and cons and one may prefer one paradigm over the other. If you are a Rust developer and wants to venture into functional programming, do not worry, you don’t have to learn functional programming oriented languages like Haskell or Clojure(or even Scala or JavaScript though they are not pure functional programming languages) since Rust has you covered and this post is for you.</p><p>If you are looking for functional programming in Java, Golang or TypeScript check other posts in the series.</p><p>I’m not gonna dive into all functional programming concepts in detail, instead, I’m gonna focus on things that you can do in Rust that are in line with functional programming concepts. I’m also not gonna discuss the pros and cons of functional programming in general.</p><p>Please note that some introductions in this post are repeated from my other posts in the series for your ease of reading.</p><hr><h2 id="what-is-functional-programming">What is functional programming?</h2><p>As per Wikipedia,</p><blockquote><p>Functional programming is a programming paradigm—a style of building the structure and elements of computer programs—that treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data.</p></blockquote><p>Hence in functional programming, there are two very important rules</p><ul><li><strong>No Data mutations</strong>: It means a data object should not be changed after it is created.</li><li><strong>No implicit state</strong>: Hidden/Implicit state should be avoided. In functional programming state is not eliminated, instead, its made visible and explicit</li></ul><p>This means:</p><ul><li><strong>No side effects</strong>: A function or operation should not change any state outside of its functional scope. I.e, A function should only return a value to the invoker and should not affect any external state. This means programs are easier to understand.</li><li><strong>Pure functions only</strong>: Functional code is idempotent. A function should return values only based on the arguments passed and should not affect(side-effect) or depend on the global state. Such functions always produce the same result for the same arguments.</li></ul><p>Apart from these there are functional programming concepts below that can be applied in Rust, we will touch upon these further down.</p><ul><li><a href="https://en.wikipedia.org/wiki/Higher-order_function">Higher-order-functions</a></li><li><a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">Closures</a></li><li><a href="https://en.wikipedia.org/wiki/Currying">Currying</a></li><li><a href="https://en.wikipedia.org/wiki/Recursion_(computer_science)">Recursion</a></li><li><a href="https://en.wikipedia.org/wiki/Evaluation_strategy">Lazy evaluations</a></li><li><a href="https://en.wikipedia.org/wiki/Referential_transparency">Referential transparency</a></li></ul><p>Using functional programming doesn’t mean it’s all or nothing, you can always use functional programming concepts to complement Object-oriented or imperative concepts in Rust. The benefits of functional programming can be utilized whenever possible regardless of the paradigm or language you use. And that is exactly what we are going to see.</p><hr><h2 id="functional-programming-in-rust">Functional programming in Rust</h2><p>Rust is primarily geared towards the procedural/imperative style of programming but it also lets you do the functional and object-oriented style of programming as well. And that is my favorite kind of mix. So let us see how we can apply some of the functional programming concepts above in Rust using the language features.</p><h3 id="first-class-and-higher-order-functions">First-class and higher-order functions</h3><p>First-class functions(function as a first-class citizen) mean you can assign functions to variables, pass a function as an argument to another function or return a function from another. Functions in Rust are a bit more complex than other languages, it’s not as straightforward as in Go or JavaScript. There are different kinds of functions and two different ways of writing them. The first one is a function that cannot memoize its outer context and the second one is closures which can memoize its outer context. Hence concepts like currying and higher-order functions are possible in Rust but may not be as easy to wrap your head around as in other languages. Also, functions that accept a closure can accept a pointer to a function depending on the context. In many places, Rust functions and closures can be interchangeable. It would have been nicer if functions were simple and we could do all the below without having to rely on closures. But Rust chose these compromises for better memory safety and performance.</p><p>A function can be considered as a higher-order function only if it takes one or more functions as parameters or if it returns another function as a result. In Rust, this is quite easy to do with closures, it might look a bit verbose but if you are familiar with Rust then you should be fine.</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">list</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span>
        <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Orange"</span><span class="p">),</span>
        <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Apple"</span><span class="p">),</span>
        <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Banana"</span><span class="p">),</span>
        <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Grape"</span><span class="p">),</span>
    <span class="p">];</span>
    <span class="c">// we are passing the array and a closure as arguments to map_for_each method.</span>
    <span class="k">let</span> <span class="n">out</span> <span class="o">=</span> <span class="nf">map_for_each</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="p">|</span><span class="n">it</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">String</span><span class="p">|</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">it</span><span class="nf">.len</span><span class="p">();</span>
    <span class="p">});</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">out</span><span class="p">);</span> <span class="c">// [6, 5, 6, 5]</span>
<span class="p">}</span>

<span class="c">// The higher-order-function takes an array and a closure as arguments</span>
<span class="k">fn</span> <span class="nf">map_for_each</span><span class="p">(</span><span class="n">list</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">fun</span><span class="p">:</span> <span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">new_array</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">for</span> <span class="n">it</span> <span class="n">in</span> <span class="n">list</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
        <span class="c">// We are executing the closure passed</span>
        <span class="n">new_array</span><span class="nf">.push</span><span class="p">(</span><span class="nf">fun</span><span class="p">(</span><span class="n">it</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">new_array</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div><p>There are also more complex versions that you can write with generics like below for an example</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">list</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">];</span>
    <span class="c">// we are passing the array and a closure as arguments to map_for_each method.</span>
    <span class="k">let</span> <span class="n">out</span> <span class="o">=</span> <span class="nf">map_for_each</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="p">|</span><span class="n">it</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">usize</span><span class="p">|</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">it</span> <span class="o">*</span> <span class="n">it</span><span class="p">;</span>
    <span class="p">});</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">out</span><span class="p">);</span> <span class="c">// [4, 25, 64, 100]</span>
<span class="p">}</span>

<span class="c">// The higher-order-function takes an array and a closure as arguments, but uses generic types</span>
<span class="k">fn</span> <span class="n">map_for_each</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">&gt;</span><span class="p">(</span><span class="n">list</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">fun</span><span class="p">:</span> <span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">A</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">B</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">new_array</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">for</span> <span class="n">it</span> <span class="n">in</span> <span class="n">list</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
        <span class="c">// We are executing the closure passed</span>
        <span class="n">new_array</span><span class="nf">.push</span><span class="p">(</span><span class="nf">fun</span><span class="p">(</span><span class="n">it</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">new_array</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div><p>But then we could also simply do it this way using built-in functional methods like map, fold(reduce) and so on which is much less verbose. Rust provides a lot of useful functional style methods for working on collections like <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">fold</code>, <code class="language-plaintext highlighter-rouge">for_each</code>, <code class="language-plaintext highlighter-rouge">filter</code>, and so on.</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">list</span> <span class="o">=</span> <span class="p">[</span><span class="s">"Orange"</span><span class="p">,</span> <span class="s">"Apple"</span><span class="p">,</span> <span class="s">"Banana"</span><span class="p">,</span> <span class="s">"Grape"</span><span class="p">];</span>

    <span class="c">// we are passing a closure as arguments to the built-in map method.</span>
    <span class="k">let</span> <span class="n">out</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">list</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span><span class="nf">.len</span><span class="p">())</span><span class="nf">.collect</span><span class="p">();</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">out</span><span class="p">);</span> <span class="c">// [6, 5, 6, 5]</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div><p>Closures in Rust can memorize and mutate their outer context but due to the concept of ownership in Rust, you cannot have multiple closures mutating the same variables in the outer context. Currying is also possible in Rust but again due to ownership and lifetime concepts, it might feel a bit more verbose.</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// this is a higher-order-function that returns a closure</span>
    <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nf">Fn</span><span class="p">(</span><span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="c">// A closure is returned here</span>
        <span class="c">// variable x is obtained from the outer scope of this method and memorized in the closure by moving ownership</span>
        <span class="k">return</span> <span class="k">move</span> <span class="p">|</span><span class="n">y</span><span class="p">|</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="p">};</span>
    <span class="p">};</span>

    <span class="c">// we are currying the add method to create more variations</span>
    <span class="k">let</span> <span class="n">add10</span> <span class="o">=</span> <span class="nf">add</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">add20</span> <span class="o">=</span> <span class="nf">add</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">add30</span> <span class="o">=</span> <span class="nf">add</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">add10</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span> <span class="c">// 15</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">add20</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span> <span class="c">// 25</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">add30</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span> <span class="c">// 35</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div><h3 id="pure-functions">Pure functions</h3><p>As we saw already a pure function should return values only based on the arguments passed and should not affect or depend on the global state. It is possible to do this in Rust easily.</p><p>Take the below, this is a pure function. It will always return the same output for the given input and its behavior is highly predictable. We can safely cache the method if needed.</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">sum</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div><p>But since Rust variables are immutable by default, unless specified a function cannot mutate any variables passed to it and cannot capture any variable in its context. So if we try to affect external state like below the compiler will complain “can’t capture the dynamic environment in an fn item”</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">holder</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">fn</span> <span class="nf">sum</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
        <span class="n">holder</span><span class="nf">.insert</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"${a}+${b}"</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">)),</span> <span class="n">c</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div><p>In Rust, to capture external state, we would have to use closures, so we can rewrite the above as</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">holder</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">sum</span> <span class="o">=</span> <span class="p">|</span><span class="n">a</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">usize</span><span class="p">|</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
        <span class="n">holder</span><span class="nf">.insert</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"${a}+${b}"</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">)),</span> <span class="n">c</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">sum</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">));</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div><p>But the compilation will still fail with the message “cannot borrow <code class="language-plaintext highlighter-rouge">sum</code> as mutable, as it is not declared as mutable”. So to do external state mutation, we would have to explicitly specify the function as mutable like <code class="language-plaintext highlighter-rouge">let mut sum = ...</code></p><p>So Rust will help you keep your functions pure and simple by default. Of course, that doesn’t mean you can avoid side effects that don’t involve variable mutations, for those you have to take care of it yourself.</p><h3 id="recursion">Recursion</h3><p>Functional programming favors recursion over looping. Let us see an example for calculating the factorial of a number. I did some benchmarks and added the ns/op results inline as a comment</p><p>In traditional iterative approach:</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="c">// Average  8.5858 ns/op</span>
    <span class="k">fn</span> <span class="nf">factorial</span><span class="p">(</span><span class="k">mut</span> <span class="n">num</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">*=</span> <span class="n">num</span><span class="p">;</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">factorial</span><span class="p">(</span><span class="mi">20</span><span class="p">));</span> <span class="c">// 2432902008176640000</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div><p>The same can be done using recursion as below which is favored in functional programming – But recursion is not the solution always, for some cases a simple loop is more readable in my personal opinion.</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="c">// Average  8.6150 ns/op</span>
    <span class="k">fn</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">num</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">match</span> <span class="n">num</span> <span class="p">{</span>
            <span class="mi">0</span> <span class="k">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
            <span class="mi">_</span> <span class="k">=&gt;</span> <span class="n">num</span> <span class="o">*</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
        <span class="p">};</span>
    <span class="p">}</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">factorial</span><span class="p">(</span><span class="mi">20</span><span class="p">));</span> <span class="c">// 2432902008176640000</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div><p>The downside of the recursive approach, in general, is that it might result in stack overflow errors since every function call needs to be saved as a frame to the stack. To avoid this tail recursion is preferred, especially when the recursion is done too many times. In tail recursion, the recursive call is the last thing executed by the function and hence the functions stack frame need not be saved by the compiler. Most compilers can optimize the tail recursion code the same way iterative code is optimized hence avoiding the performance penalty. In Rust this mostly is not an issue due to Rust’s <a href="https://deepu.tech/my-second-impression-of-rust/">zero-cost abstractions</a> as both the imperative and recursive code will be compiled down to <a href="https://godbolt.org/z/v593nhKoh">same assembly</a> in most cases.</p><p>Rust also does tail-call optimizations but it’s not always guaranteed. The same use-case with the tail call will look like this.</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="c">// Average  8.6869 ns/op</span>
    <span class="k">fn</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">num</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="nf">factorial_inner</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">factorial_inner</span><span class="p">(</span><span class="n">acc</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">match</span> <span class="n">val</span> <span class="p">{</span>
            <span class="mi">1</span> <span class="k">=&gt;</span> <span class="n">acc</span><span class="p">,</span>
            <span class="mi">_</span> <span class="k">=&gt;</span> <span class="nf">factorial_tail_inner</span><span class="p">(</span><span class="n">acc</span> <span class="o">*</span> <span class="n">val</span><span class="p">,</span> <span class="n">val</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
        <span class="p">};</span>
    <span class="p">}</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">factorial</span><span class="p">(</span><span class="mi">20</span><span class="p">));</span> <span class="c">// 2432902008176640000</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div><p>For factorials, there is an even better way using iterators which performs the best</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="c">// Average 6.6387 ns/op</span>
    <span class="k">fn</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">num</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="n">num</span><span class="p">)</span><span class="nf">.fold</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">|</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">|</span> <span class="n">n1</span> <span class="o">*</span> <span class="n">n2</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">factorial</span><span class="p">(</span><span class="mi">20</span><span class="p">));</span> <span class="c">// 2432902008176640000</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div><p>Consider using recursion when writing Rust code for readability and immutability and due to Rust’s zero-cost abstractions we don’t have to worry about performance.</p><h3 id="lazy-evaluation">Lazy evaluation</h3><p>Lazy evaluation or non-strict evaluation is the process of delaying the evaluation of an expression until it is needed. In general, Rust does strict/eager evaluations. We can utilize higher-order functions, closures, and <a href="https://en.wikipedia.org/wiki/Memoization">memoization</a> techniques to do lazy evaluations.</p><p>Take this example where Rust eagerly evaluates everything.</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"executing add"</span><span class="p">);</span> <span class="c">// this is printed since the functions are evaluated first</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">multiply</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"executing multiply"</span><span class="p">);</span> <span class="c">// this is printed since the functions are evaluated first</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">add_or_multiply</span><span class="p">(</span><span class="n">add</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">on_add</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">on_multiply</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">add</span> <span class="p">{</span>
            <span class="n">on_add</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">on_multiply</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">add_or_multiply</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nf">add</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="nf">multiply</span><span class="p">(</span><span class="mi">4</span><span class="p">)));</span> <span class="c">// 8</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">add_or_multiply</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nf">add</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="nf">multiply</span><span class="p">(</span><span class="mi">4</span><span class="p">)));</span> <span class="c">// 16</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div><p>This will produce the below output and we can see that both functions are executed always</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>executing add
executing multiply
8
executing add
executing multiply
16
</pre></td></tr></tbody></table></code></pre></div></div><p>We can use higher-order-functions to rewrite this into a lazily evaluated version</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"executing add"</span><span class="p">);</span> <span class="c">// this is printed since the functions are evaluated first</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">multiply</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"executing multiply"</span><span class="p">);</span> <span class="c">// this is printed since the functions are evaluated first</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">type</span> <span class="n">FnType</span> <span class="o">=</span> <span class="k">fn</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>

    <span class="c">// This is now a higher-order-function hence evaluation of the functions are delayed in if-else</span>
    <span class="k">fn</span> <span class="nf">add_or_multiply</span><span class="p">(</span><span class="n">add</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">on_add</span><span class="p">:</span> <span class="n">FnType</span><span class="p">,</span> <span class="n">on_multiply</span><span class="p">:</span> <span class="n">FnType</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">add</span> <span class="p">{</span>
            <span class="nf">on_add</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">on_multiply</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">add_or_multiply</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="n">multiply</span><span class="p">,</span> <span class="mi">4</span><span class="p">));</span> <span class="c">// 8</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">add_or_multiply</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="n">multiply</span><span class="p">,</span> <span class="mi">4</span><span class="p">));</span> <span class="c">// 16</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div><p>This outputs the below and we can see that only required functions were executed</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>executing add
8
executing multiply
16
</pre></td></tr></tbody></table></code></pre></div></div><p>You can also use memoization/caching techniques to avoid unwanted evaluations in pure and referentially transparent functions like below</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cached_added</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">add</span> <span class="o">=</span> <span class="p">|</span><span class="n">x</span><span class="p">:</span> <span class="nb">usize</span><span class="p">|</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">match</span> <span class="n">cached_added</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">val</span><span class="p">,</span>
            <span class="mi">_</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="s">"executing add"</span><span class="p">);</span>
                <span class="k">let</span> <span class="n">out</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="p">;</span>
                <span class="n">cached_added</span><span class="nf">.insert</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">);</span>
                <span class="n">out</span>
            <span class="p">}</span>
        <span class="p">};</span>
    <span class="p">};</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">cached_multiplied</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">multiply</span> <span class="o">=</span> <span class="p">|</span><span class="n">x</span><span class="p">:</span> <span class="nb">usize</span><span class="p">|</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">match</span> <span class="n">cached_multiplied</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">val</span><span class="p">,</span>
            <span class="mi">_</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"executing multiply"</span><span class="p">);</span>
                <span class="k">let</span> <span class="n">out</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
                <span class="n">cached_multiplied</span><span class="nf">.insert</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">);</span>
                <span class="n">out</span>
            <span class="p">}</span>
        <span class="p">};</span>
    <span class="p">};</span>

    <span class="k">fn</span> <span class="nf">add_or_multiply</span><span class="p">(</span><span class="n">add</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">on_add</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">on_multiply</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">add</span> <span class="p">{</span>
            <span class="n">on_add</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">on_multiply</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">add_or_multiply</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nf">add</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="nf">multiply</span><span class="p">(</span><span class="mi">4</span><span class="p">)));</span> <span class="c">// 8</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">add_or_multiply</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nf">add</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="nf">multiply</span><span class="p">(</span><span class="mi">4</span><span class="p">)));</span> <span class="c">// 16</span>
<span class="p">}</span>

</pre></td></tr></tbody></table></code></pre></div></div><p>This outputs the below and we can see that functions were executed only once for the same values.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>executing add
executing multiply
8
16
</pre></td></tr></tbody></table></code></pre></div></div><p>These may not look that elegant especially to seasoned Rust programmers. Fortunately, most of the functional APIs, like the iterators, provided by Rust do lazy evaluations and there are libraries like <a href="https://github.com/reem/rust-lazy">rust-lazy</a> and <a href="https://docs.rs/thunk/0.3.0/thunk/">Thunk</a> which can be used to make functions lazy. Also, Rust provides some advanced types with which lazy evaluations can be implemented.</p><p>Doing Lazy evaluations in Rust might not be worth the code complexity some of the times, but if the functions in question are heavy in terms of processing then it is worth it to lazy evaluate them.</p><h3 id="type-system">Type system</h3><p>Rust is a strong statically typed language and also has great type inference. There are also advanced concepts like type aliasing and so on.</p><h3 id="referential-transparency">Referential transparency</h3><p>From Wikipedia:</p><blockquote><p>Functional programs do not have assignment statements, that is, the value of a variable in a functional program never changes once defined. This eliminates any chances of side effects because any variable can be replaced with its actual value at any point of execution. So, functional programs are referentially transparent.</p></blockquote><p>Rust has great ways to ensure referential transparency, variables in Rust are immutable by default and even reference passing is immutable by default. So you would have to explicitly mark variables or references as mutable to do so. So in Rust, it is quite easy to avoid mutations.</p><p>For example, the below will produce an error</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">list</span> <span class="o">=</span> <span class="p">[</span><span class="s">"Apple"</span><span class="p">,</span> <span class="s">"Orange"</span><span class="p">,</span> <span class="s">"Banana"</span><span class="p">,</span> <span class="s">"Grape"</span><span class="p">];</span>

    <span class="n">list</span> <span class="o">=</span> <span class="p">[</span><span class="s">"John"</span><span class="p">,</span> <span class="s">"Raju"</span><span class="p">,</span> <span class="s">"Sabi"</span><span class="p">,</span> <span class="s">"Vicky"</span><span class="p">];</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div><p>And so does all of the below</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">list</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span>
        <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Orange"</span><span class="p">),</span>
        <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Apple"</span><span class="p">),</span>
        <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Banana"</span><span class="p">),</span>
        <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Grape"</span><span class="p">),</span>
    <span class="p">];</span>

    <span class="n">list</span><span class="nf">.push</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Strawberry"</span><span class="p">));</span> <span class="c">// This will fail as the reference is immutable</span>

    <span class="k">fn</span> <span class="nf">mutating_fn</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">val</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'!'</span><span class="p">);</span> <span class="c">// this will fail unless the argument is marked mutable reference or value passed is marked mutable reference</span>
    <span class="p">}</span>

    <span class="nf">mutating_fn</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Strawberry"</span><span class="p">));</span> <span class="c">// this will fail if the reference is not passed as mutable</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div><p>To compile these, we would have to riddle it with <code class="language-plaintext highlighter-rouge">mut</code> keywords</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">list</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span>
        <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Orange"</span><span class="p">),</span>
        <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Apple"</span><span class="p">),</span>
        <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Banana"</span><span class="p">),</span>
        <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Grape"</span><span class="p">),</span>
    <span class="p">];</span>

    <span class="n">list</span><span class="nf">.push</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Strawberry"</span><span class="p">));</span> <span class="c">// This will work as the reference is mutable</span>

    <span class="k">fn</span> <span class="nf">mutating_fn</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">val</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'!'</span><span class="p">);</span> <span class="c">// this will work as the argument is marked as a mutable reference</span>
    <span class="p">}</span>

    <span class="nf">mutating_fn</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Strawberry"</span><span class="p">));</span> <span class="c">// this will work as the reference is passed as mutable</span>
<span class="p">}</span>

</pre></td></tr></tbody></table></code></pre></div></div><p>There are even more advanced concepts in Rust when it comes to data mutation and all that makes it easier to write immutable code.</p><h3 id="data-structures"><a href="https://en.wikipedia.org/wiki/Purely_functional_data_structure">Data structures</a></h3><p>When using functional programming techniques it is encouraged to use data types such as Stacks, Maps, and Queues as they also have functional implementations. Hence Hashmaps are better than arrays or hash sets as data stores in functional programming. Rust provides such data types and is hence conforms to the functional specifications regarding data structures.</p><hr><h2 id="conclusion">Conclusion</h2><p>This is just an introduction for those who are trying to apply some functional programming techniques in Rust. There are a lot more that can be done in Rust. As I said earlier functional programming is not a silver bullet but it offers a lot of useful techniques for more understandable, maintainable, and testable code. It can co-exist perfectly well with imperative and object-oriented programming styles. In fact, we all should be using the best of everything to solve the problem at hand instead of getting too obsessed with a single methodology.</p><hr><p>I hope you find this useful. If you have any questions or if you think I missed something please add a comment.</p><p>If you like this article, please leave a like or a comment.</p><p>You can follow me on <a href="https://twitter.com/deepu105">Twitter</a> and <a href="https://www.linkedin.com/in/deepu05/">LinkedIn</a>.</p></div><hr><p>Post <strong>4</strong> of <strong>4</strong> in series <strong>"functional-programming"</strong>.</p><p></p><div class="row PageNavigation d-flex justify-content-between font-weight-bold"><a class="prev d-block col-md-6" rel="prev" href="/functional-programming-in-typescript/">&laquo; Prev post in series</a><div class="clearfix"></div></div><div class="after-post-cats"><ul class="tags mb-4"></ul></div><div class="after-post-tags"><ul class="tags"><li><a class="smoothscroll" href="/tags#beginners">#beginners</a></li><li><a class="smoothscroll" href="/tags#functional">#functional</a></li><li><a class="smoothscroll" href="/tags#programming">#programming</a></li><li><a class="smoothscroll" href="/tags#rust">#rust</a></li></ul></div><div class="row PageNavigation d-flex justify-content-between font-weight-bold"><a class="prev d-block col-md-6" href="/first-impression-of-rust/">&laquo; My first impressions of Rust</a> <a class="next d-block col-md-6 text-lg-right" href="/reflections-on-javascript/">My love-hate relationship with JavaScript &raquo;</a><div class="clearfix"></div></div><hr></div></div></div><div class="container"><div id="comments" class="row justify-content-center mb-5"><div class="col-md-8"><section class="hyvor"><div id="hyvor-talk-view"></div><script type="text/javascript">var HYVOR_TALK_WEBSITE=4123,HYVOR_TALK_CONFIG={url:"https://deepu.tech/functional-programming-in-rust/",id:"https://deepu.tech/functional-programming-in-rust/"}</script><script async type="text/javascript" src="//talk.hyvor.com/web-api/embed"></script></section></div></div></div></div><div class="alertbar"><div class="container text-center"><span>Never miss a <b>story</b> from us, subscribe to our newsletter</span><form action="https://tech.us7.list-manage.com/subscribe/post?u=00729f6c6d6bb180801b9484e&amp;id=f521dede4b" method="post" name="mc-embedded-subscribe-form" id="mc-embedded-subscribe-form" class="wj-contact-form validate" target="_blank" novalidate><div class="mc-field-group"><input type="email" placeholder="Email address" name="EMAIL" class="required email" id="mce-EMAIL" autocomplete="on" required> <input type="submit" value="Subscribe" name="subscribe" class="heart"></div></form></div></div></div><div class="jumbotron fortags lozad" data-background-image="/assets/images/jumbotron.jpg"><div class="d-md-flex h-100"><div class="col-md-4 transpdark align-self-center text-center h-100"><div class="d-md-flex align-items-center justify-content-center h-100"><h2 class="d-md-block align-self-center py-1 font-weight-light">Explore <span class="d-none d-md-inline">→</span></h2></div></div><div class="col-md-8 pt-1 ph-2 align-self-center text-center h-100"><a class="mt-1 mb-1" href="/tags#languages">languages (14)</a> <a class="mt-1 mb-1" href="/tags#programming">programming (14)</a> <a class="mt-1 mb-1" href="/tags#javascript">javascript (13)</a> <a class="mt-1 mb-1" href="/tags#java">java (10)</a> <a class="mt-1 mb-1" href="/tags#beginners">beginners (8)</a> <a class="mt-1 mb-1" href="/tags#rust">rust (8)</a> <a class="mt-1 mb-1" href="/tags#concurrency">concurrency (6)</a> <a class="mt-1 mb-1" href="/tags#go">go (6)</a> <a class="mt-1 mb-1" href="/tags#linux">linux (5)</a> <a class="mt-1 mb-1" href="/tags#microservices">microservices (5)</a> <a class="mt-1 mb-1" href="/tags#typescript">typescript (5)</a> <a class="mt-1 mb-1" href="/tags#computerscience">computerscience (4)</a> <a class="mt-1 mb-1" href="/tags#development">development (4)</a> <a class="mt-1 mb-1" href="/tags#fedora">fedora (4)</a> <a class="mt-1 mb-1" href="/tags#functional">functional (4)</a> <a class="mt-1 mb-1" href="/tags#async">async (3)</a> <a class="mt-1 mb-1" href="/tags#jhipster">jhipster (3)</a> <a class="mt-1 mb-1" href="/tags#kubernetes">kubernetes (3)</a> <a class="mt-1 mb-1" href="/tags#thepragmaticprogrammer">thepragmaticprogrammer (3)</a> <a class="mt-1 mb-1" href="/tags#azure">azure (2)</a> <a class="mt-1 mb-1" href="/tags#career">career (2)</a> <a class="mt-1 mb-1" href="/tags#codequality">codequality (2)</a> <a class="mt-1 mb-1" href="/tags#deno">deno (2)</a> <a class="mt-1 mb-1" href="/tags#discuss">discuss (2)</a> <a class="mt-1 mb-1" href="/tags#docker">docker (2)</a> <a class="mt-1 mb-1" href="/tags#garbagecollection">garbagecollection (2)</a> <a class="mt-1 mb-1" href="/tags#gnome">gnome (2)</a> <a class="mt-1 mb-1" href="/tags#golang">golang (2)</a> <a class="mt-1 mb-1" href="/tags#kde">kde (2)</a> <a class="mt-1 mb-1" href="/tags#node">node (2)</a> <a class="mt-1 mb-1" href="/tags#nodejs">nodejs (2)</a> <a class="mt-1 mb-1" href="/tags#react">react (2)</a> <a class="mt-1 mb-1" href="/tags#showdev">showdev (2)</a> <a class="mt-1 mb-1" href="/tags#webdev">webdev (2)</a> <a class="mt-1 mb-1" href="/tags#architecture">architecture (1)</a> <a class="mt-1 mb-1" href="/tags#bash">bash (1)</a> <a class="mt-1 mb-1" href="/tags#blogging">blogging (1)</a> <a class="mt-1 mb-1" href="/tags#books">books (1)</a> <a class="mt-1 mb-1" href="/tags#clojure">clojure (1)</a> <a class="mt-1 mb-1" href="/tags#codenewbie">codenewbie (1)</a> <a class="mt-1 mb-1" href="/tags#desktop">desktop (1)</a> <a class="mt-1 mb-1" href="/tags#developerexperience">developerexperience (1)</a> <a class="mt-1 mb-1" href="/tags#devops">devops (1)</a> <a class="mt-1 mb-1" href="/tags#devrel">devrel (1)</a> <a class="mt-1 mb-1" href="/tags#distributedsystems">distributedsystems (1)</a> <a class="mt-1 mb-1" href="/tags#engineering">engineering (1)</a> <a class="mt-1 mb-1" href="/tags#gaming">gaming (1)</a> <a class="mt-1 mb-1" href="/tags#ide">ide (1)</a> <a class="mt-1 mb-1" href="/tags#interview">interview (1)</a> <a class="mt-1 mb-1" href="/tags#istio">istio (1)</a> <a class="mt-1 mb-1" href="/tags#jdk">jdk (1)</a> <a class="mt-1 mb-1" href="/tags#Jekyll">Jekyll (1)</a> <a class="mt-1 mb-1" href="/tags#js">js (1)</a> <a class="mt-1 mb-1" href="/tags#jvm">jvm (1)</a> <a class="mt-1 mb-1" href="/tags#kotlin">kotlin (1)</a> <a class="mt-1 mb-1" href="/tags#medium">medium (1)</a> <a class="mt-1 mb-1" href="/tags#memory-management">memory-management (1)</a> <a class="mt-1 mb-1" href="/tags#motivation">motivation (1)</a> <a class="mt-1 mb-1" href="/tags#multithreading">multithreading (1)</a> <a class="mt-1 mb-1" href="/tags#ohmyzsh">ohmyzsh (1)</a> <a class="mt-1 mb-1" href="/tags#openjdk">openjdk (1)</a> <a class="mt-1 mb-1" href="/tags#opensource">opensource (1)</a> <a class="mt-1 mb-1" href="/tags#patternmatching">patternmatching (1)</a> <a class="mt-1 mb-1" href="/tags#polyglot">polyglot (1)</a> <a class="mt-1 mb-1" href="/tags#pragmatic">pragmatic (1)</a> <a class="mt-1 mb-1" href="/tags#python">python (1)</a> <a class="mt-1 mb-1" href="/tags#ruby">ruby (1)</a> <a class="mt-1 mb-1" href="/tags#scala">scala (1)</a> <a class="mt-1 mb-1" href="/tags#svelte">svelte (1)</a> <a class="mt-1 mb-1" href="/tags#tech">tech (1)</a> <a class="mt-1 mb-1" href="/tags#terminal">terminal (1)</a> <a class="mt-1 mb-1" href="/tags#terraform">terraform (1)</a> <a class="mt-1 mb-1" href="/tags#ubuntu">ubuntu (1)</a> <a class="mt-1 mb-1" href="/tags#v8">v8 (1)</a> <a class="mt-1 mb-1" href="/tags#vr">vr (1)</a> <a class="mt-1 mb-1" href="/tags#vscode">vscode (1)</a> <a class="mt-1 mb-1" href="/tags#web">web (1)</a> <a class="mt-1 mb-1" href="/tags#WebAssembly">WebAssembly (1)</a> <a class="mt-1 mb-1" href="/tags#webassembly">webassembly (1)</a> <a class="mt-1 mb-1" href="/tags#windows">windows (1)</a> <a class="mt-1 mb-1" href="/tags#womenintech">womenintech (1)</a> <a class="mt-1 mb-1" href="/tags#writing">writing (1)</a> <a class="mt-1 mb-1" href="/tags#zsh">zsh (1)</a></div></div></div><footer class="footer"><div class="container"><div class="row"><div class="col-md-6 col-sm-6 text-center text-lg-left">Copyright © 2022 Deepu K Sasidharan<br><a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img class="lozad" alt="Creative Commons License" style="border-width:0" src="/assets/images/placeholder.jpg" data-src="https://i.creativecommons.org/l/by/4.0/88x31.png"> </a>Content licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</div><div class="col-md-6 col-sm-6 text-center text-lg-right"><a target="_blank" href="https://www.wowthemes.net/mediumish-free-jekyll-template/">Mediumish Jekyll Theme</a> by WowThemes.net | Domain by <a href="https://js.org" target="_blank" title="JS.ORG | JavaScript Community"><img src="/assets/images/placeholder.jpg" data-src="https://logo.js.org/dark_tiny.png" style="width:50px" alt="JS.ORG Logo" class="lozad"> </a>| Hosted with <i class="far fa-heart"></i> by <a href="https://pages.github.com/" target="_blank">Github</a></div></div></div></footer></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.slim.min.js" integrity="sha256-pasqAKBDmFT4eHoN2ndd6lN370kFiGUFyTiUHWhU7k8=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.8/lunr.min.js" integrity="sha256-34Si1Y6llMBKM3G0jQILVeoQKEwuxjbk4zGWXXMT4ps=" crossorigin="anonymous"></script><script async src="/assets/js/lunrsearchengine.js"></script><script async src="/assets/js/mediumish.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.14.0/lozad.min.js" integrity="sha256-hstwhDmGVwZjIwt6SlTG6sQBREWrWTBjVTik/JLlb1Y=" crossorigin="anonymous"></script><script>// lazy loads images
        const lazyloadObserver = lozad()
        lazyloadObserver.observe();</script><script async src="/assets/js/ie10-viewport-bug-workaround.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-74370272-6"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-74370272-6")</script></body></html>